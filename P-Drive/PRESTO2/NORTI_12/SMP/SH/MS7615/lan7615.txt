_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/

                               NORTi Network
                            LANデバイスドライバ

                                2000-08-08版

                              テクニカルノート

_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/


■はじめに

LANドライバは、NORTi Networkのプロトコルスタック部の中で内部的に利用される
機能を提供するプログラムモジュールです。したがって、アプリケーションプログラ
ムを作成するユーザは、その存在を意識する必要は特にありません。

しかしながら、NORTi Networkそのものの移植を試みるユーザにとっては、LANドラ
イバの内部処理について理解することは必要な知識となります。本テキストファイル
は、このようなユーザに当該情報を与える目的で用意されたものです。

本テキストファイルは、LANドライバに関してのみ説明を行なっています。
LANドライバとは別に「LANコントローラハードウェア依存の部分」については、
『SH7615 ハードウェアマニュアル／日立』を参照してください。

■デバイス構成

本ドライバは、下記のデバイス構成を持つターゲットシステムに対応しています。

 +-------------------------------------------------------------------------+
 |  データリンクタイプ  Ethernet（10BASE/100BASE）                         |
 |  デバイスチップ      National Semiconductor DP83843(PHY controller)     |
 |                      Ether Controller on SH7615                         |
 |  ターゲットボード    日立超LSIシステムズ MS7615SE01                     |
 |  データ転送方式      SH7615内蔵 Ether-DMA                               |
 |  割り込み            受信, 送信（共有）                                 |
 +-------------------------------------------------------------------------+

■構成ファイル

本ドライバは、主に次のファイルにより構成されます。

  dp83843.c -------- DP83843 PHYコントローラI/Fサンプル
  dp83843.h -------- DP83843 PHYコントローラI/Fヘッダ
  sh7615e.c -------- SH7615  LANコントローラドライバ
  sh7615e.h -------- SH7615  LANコントローラドライバ
  sh7615.h  -------- SH7615  内部I/O定義

■コンフィグレーション１

PHY(DP83843)ディバイスアドレスの設定

    MIIのディバイス局アドレスのデフォルトは、0x01 です。
    これを変更する場合、PHYAD マクロを定義してコンパイルしてください。

    (例) shc <option> -def=PHYAD=0x03 dp83843.c --- ルネサスC
                      ~~~~~~~~~~~~~~~
    (例) gcc <option> -DPHYAD=0x03 dp83843.c  ----- exeGCC
                      ~~~~~~~~~~~~
    (例) ccsh <options> -DPHYAD=0x03 dp83843.c ---- Green Hills
                        ~~~~~~~~~~~~

強制ループバックの設定

    PHY(DP83843)内部 折り返しの設定を有効にする場合には
    LOOP_BACK マクロを定義してコンパイルしてください。

    (例) shc <option> -def=LOOP_BACK dp83843.c
                      ~~~~~~~~~~~~~~
    (例) gcc <option> -DLOOP_BACK dp83843.c
                      ~~~~~~~~~~~
    (例) ccsh <options> -DLOOP_BACK dp83843.c
                        ~~~~~~~~~~~

■コンフィグレーション２

    通信モード(全２重／半２重)、通信速度(10base/100base)、および、
    Auto Negotiationの選択は、DP83843(PHY)コントローラに持つ機能
    ですが、設定は ドライバ本体である sh7615e.c で行われます。

    ※通信モードは、sh7615 Etherコントローラにも設定があります。

強制ループバックの設定

    SH7615内部 Etherコントローラ折り返しの設定を有効にする場合には
    LOOP_BACK マクロを定義してコンパイルしてください。

    (例) shc <option> -def=LOOP_BACK sh7615e.c
                      ~~~~~~~~~~~~~~
    (例) gcc <option> -DLOOP_BACK sh7615e.c
                      ~~~~~~~~~~~
    (例) ccsh <options> -DLOOP_BACK sh7615e.c
                        ~~~~~~~~~~~

Auto Negotiationの設定

    Auto Negotiation(PHYが持つ)機能を有効にする場合には、AUTONEGO マクロ
    を定義してコンパイルしてください。AUTONEGO マクロを定義した場合には
    SPEED(10/100Mbps)の選択は無効です。デフォルトでは Auto Negotiation
    機能は無効です。全２重／半２重の自動設定は本サンプルではサポートされ
    ていません。

    (例) shc <option> -def=AUTONEGO sh7615e.c
                      ~~~~~~~~~~~~~
    (例) gcc <option> -DAUTONEGO sh7615e.c
                      ~~~~~~~~~~
    (例) ccsh <options> -DAUTONEGO sh7615e.c
                        ~~~~~~~~~~

スピードの設定

    Auto Negotiation機能を使わないで固定モードで使用する場合には SPEED
    マクロで動作スピードを変更できます。デフォルトでは 10Mbps になりま
    す。SPEED マクロには、10 または 100 の値を設定してください。
    それ以外の設定はエラーとなります。また AUTONEGO マクロを定義した場合
    には SPEED(10/100Mbps)の選択は無効です。
    次の設定では 100Mbps になります。

    (例) shc <option> -def=SPEED=100 sh7615e.c
                      ~~~~~~~~~~~~~~
    (例) gcc <option> -DSPEED=100 sh7615e.c
                      ~~~~~~~~~~~
    (例) ccsh <options> -DSPEED=100 sh7615e.c
                        ~~~~~~~~~~~

全２重／半２重の設定

    全２重を設定する場合には、FULL マクロを定義してコンパイルしてくださ
    い。デフォルトでは 半２重に設定されます。Auto Negotiationの全２重／
    半２重選択は固定されます。

    (例) shc <option> -def=FULL sh7615e.c
                      ~~~~~~~~~
    (例) gcc <option> -DFULL sh7615e.c
                      ~~~~~~
    (例) ccsh <options> -DFULL sh7615e.c
                        ~~~~~~


■機能概要

LANドライバは、ターゲットボードが搭載するLANコントローラを制御することにより、
ネットワーク通信の基礎的機能であるパケット送受信処理を実現するプログラムモジ
ュールです。LANドライバにより提供される機能はプロトコルスタック部からのみ利
用されます。

NORTi NetworkのLANドライバは、一般に次のような機能を持つことが求められます
が、本ドライバもこれらの機能を実現するための各種の処理を含んでいます。

  ・初期化操作
  ・割り込み操作
  ・受信操作
  ・送信操作

以降において、本ドライバが含む上記の各機能に相当する部分について、それぞれ詳
細を説明します。

■初期化操作

ドライバの初期化操作は、次の関数により単独で実現されます。

  ER lan_ini(UB *macaddr);

引数macaddrには、ターゲットボードに設定すべき固有のEthenetアドレスが与えられ
ます。このアドレスは、初期化操作の中でコントローラへ設定されます。

初期化操作は、以下のモジュールレベル変数を参照してコントローラの初期設定を行
ないます。

  lan_loopback_test ループバックテストモード。この変数が非０にセットされている
                    場合、コントローラをループバック動作モードにします。

  lan_inter_nouse   非割り込みモードフラグ。この変数が非０にセットされている
                    場合、コントローラの割り込みを使用しないで（ポーリング
                    モードで）送信または受信操作を実行します。

送受信操作において割り込みを使用する場合、初期化操作は、最後に、lan_def_int
という関数を呼び出します。ターゲットボードの割り込みデバイスに対する初期設定
処理はこの関数の中で行なわれます。

■割り込み操作

ドライバの割り込み操作は、次の関数により単独で実現されます。

  void lan_intr(void);

lan_intrは、コントローラから発生する割り込みを処理するための割り込みハンドラ
に相当します。ただし、この関数は lan_intという関数を経由して間接的に呼び出さ
れる形を取ります。言い換えると、CPUの割り込み機構から直接呼び出される割り込み
ハンドラは、lan_intrではなくlan_intになります。

本ドライバの割り込みハンドラは、コントローラから取得した情報に基づいて次の３
種類の割り込み要因を判定し、各割り込み要因に対応した適切な処理を行ないます。

  ・パケット受信通知(受信エラー含む)
  ・パケット送信完了(送信エラー含む)

「パケット受信通知」割り込みの場合、割り込みハンドラはlan_wai_rcvによる受信
待ち状態を解除するだけで、実際のパケットの読み出し処理は後述の『受信操作』に
任せます。同様に、「パケット送信完了」割り込みの場合、割り込みハンドラは
lan_wai_sndによる送信待ち状態を解除するだけで、後続パケットの書き込み処理は
後述の『送信操作』に任せます。

送受信で該当するエラーの発生も通常の送受信割り込みに同様な通知方法を行いま
す。SH7615 Etherコントローラは、バッファディスクプリタ方式による制御のため
割り込みによる管理は無用で、このバッファディスクプリタから取得されます。詳
しくは、「SH7615 ハードウェアマニュアル」を参照ください。

■受信操作

ドライバの受信操作は、次の関数が組み合わさって動作することにより実現されます。

  ER lan_wai_rcv(TMO tmout);
  ER lan_get_len(UH *len);
  ER lan_get_pkt(void *buf, int len);
  ER lan_get_end(void);
  ER lan_skp_pkt(int len);

lan_wai_rcvがプロトコルスタックから呼び出されると、呼び出し元のタスクはドラ
イバの中で受信割り込み待ち状態に入ります。前述のとおり、この待ち状態は割り込
みハンドラが「パケット受信通知」割り込みを認識した時点で解除されます。
lan_wai_rcv以外の関数は、受信したパケットをコントローラから読み出す処理を分
割して行ないます。

受信操作が開始されてから、受信パケットの読み出しが完了するまでの処理の流れは
次のようになります。

  (1) プロトコルスタックは、最初にlan_get_lenを呼び出して受信パケット全体の
      データ長をドライバから取得します。ドライバは、この関数の中で、バッファ
      メモリ領域内のどの位置に受信パケットが格納されているかを調べて、その情
      報を記憶します。
  (2) プロトコルスタックからlan_get_pktが繰り返し呼び出されるので、ドライバ
      は、コントローラの受信用バッファメモリ領域から順次パケットデータを読み
      出してプロトコルスタック側の受信バッファへコピーします。
  (3) 最後にlan_get_endまたはlan_skp_pktが呼び出された時点で、ドライバは、コ
      ントローラが保持している受信用バッファメモリ領域内のパケット格納可能位
      置を示すポインタを更新することにより、受信パケットを解放します。

■送信操作

ドライバの送信操作は、次の関数が組み合わさって動作することにより実現されます。

  ER lan_wai_snd(TMO tmout);
  ER lan_set_len(int len);
  ER lan_put_pkt(const void *data, int len);
  ER lan_put_dmy(int len);
  ER lan_put_end(void);

lan_wai_sndがプロトコルスタックから呼び出されると、呼び出し元のタスクはドラ
イバの中で送信バッファ(送信バッファディスクプリタ)が枯渇している場合には、
送信割り込み待ち状態に入ります。前述のとおり、この待ち状態は割り込
みハンドラが「パケット送信完了」割り込みを認識した時点で解除されます。
lan_wai_snd以外の関数は、送信するパケットをコントローラへ書き込む処理を分割
して行ないます。

送信操作が開始されてから、送信パケットの送出が実行されるまでの処理の流れは次
のようになります。

  (1) プロトコルスタックは、最初にlan_set_lenを呼び出して送信パケット全体の
      データ長をドライバへ通知します。ドライバは、この関数の中で、その情報を
      コントローラへ設定します。
  (2) プロトコルスタックからlan_put_pktまたはlan_put_dmyが繰り返し呼び出され
      るので、ドライバは、lan_put_pktでは、プロトコルスタック側の送信バッフ
      ァから順次パケットデータを読み出してコントローラの送信用バッファメモリ
      領域へコピーします。一方、lan_put_dmyでは、送信用バッファメモリ領域へ
      0をセットします。
  (3) 最後にlan_put_endが呼び出された時点で、ドライバは、送信処理を開始する
      コマンドをコントローラへ発行します。

