
FILE:  DOC\devdrv.txt

Example skeleton USNET device driver

==================================================

MODIFICATION HISTORY:

05-AUG-1998  RA  Creation

==================================================

This information is intended to update and supplement the information in the
Device Driver chapter of the USNET User's Manual. 


irhan() function 

Handle interrupts generated by the ethernet controller. 

static void irhan(int netno)
{
    unsigned int len;
    struct NET *netp;

    netp = &nets[netno];

    /* check for frame received */
    while (more frames to receive) {
        /* Check for hardware receive errors.  Increment the
           appropriate counter if an error occurred. */
        if (error receiving frame) {
            netp->ifInErrors++;
            /* clean up and continue processing */
            }
        len = size of incoming frame;
        if (QUEUE_FULL(netp->arrive)) {
            /* There are a limited number of positions in the
               network interface arrive queue.  If the queue
               is full, then the received frame must be
               discarded.  A statistic is kept of the number
               of frames that are discarded. */
            netp->ifInDiscards++;
            /* clean up and continue processing */;
        }
        if ((mess = NgetbufIR()) == 0) {
            /* If the message buffer pool has been exhausted,
               then the incoming frame must be discarded. */
            netp->ifInDiscards++;
            /* clean up and continue processing */
        }
        mess->mlen = MESSH_SZ + len;
        mess->offset = MESSH_SZ;
        mess->netno = netno;
        /* Copy the frame into the message buffer, starting
           at offset (char *)mess + MESSH_SZ.  This will be
           hardware dependent. */
        QUEUE_IN(netp, arrive, mess);
        WAITNOMORE_IR(SIG_RN(netno));
    }

    if (frame transmitted) {

lab:    if (QUEUE_EMPTY(netp, arrive);
            netp->hwflags = 0;
        else {
            QUEUE_OUT(netp, depart, mess);
            /* Check to see if we really want to transmit
               this frame.  It is possible for USNET to
               mark a frame in the depart queue as cancelled
               by changing the value of mess->offset to a
               value other than netno.  For example, if a
               frame times out waiting for an ARP reply,
               NetTask() changes offset to boTXDONE and
               releases the message buffer back into the
               pool.  If a frame has been cancelled, go on to
               the next frame in the depart queue.  */
            if (mess->offset != netno)
                goto lab;
            len = mess->mlen - MESSH_SZ;
            /* Set up the frame for transmission.  The frame
               starts at (char *)mess + MESSH_SZ and is len
               bytes long.  Note that some ethernet controllers
               will automatically pad out frames that are
               shorter than the minimum ethernet frame size,
               others may not, and so len may need to be
               adjusted.  */
            /* Once the hardware has been programmed to send a
               frame, the offset field is set to the special
               value boTXDONE to indicate to other layers that
               the device driver no longer has control of the
               message buffer. */
            mess->offset = boTXDONE;
            /* Check the id associated with the message buffer.
               If a frame is transmitted within this ISR, then
               it is the responsibility of the ISR to release
               the buffer if it is no longer needed by other
               layers in the stack.  The following code takes
               care of this. */
            if (mess->id 
                if (mess->id == bRELEASE) {
                    mess->id = bALLOC;
                    NrelbufIR(mess);
                }
            }
            else
                WAITNOMORE_IR(SIG_WN(netno));
        }
    }
}



More notes on irhan() 

The receive portion may receive a number of frames that have been queued in
hardware. The transmit section is currently designed to transmit only one
frame per interrupt, although some controllers may support more than this. 

The design of this function for DMA controllers will typically receive the
frame data directly into the message buffer, and then set up a new message
buffer after the newly received frame has been recognized. 

Typical error conditions that should be handled and tested: 
Receive overrun 
Transmit error 




writE() function 

Writes a message buffer to the network. 
Returns 1 if the frame could be transmitted immediately, 
0 if the frame is queued for later transmission 


static int writE(int conno, MESS *mess)
{
    struct NET *netp;

    (void)conno;
    netp = !=tetno];

    /* Set offset field of message header to netno to indicate
       that the frame is eligible for transmission. */
    mess->offset = mess->netno;
    /* hwflags is 1 when a transmission is in progress, and 0
       otherwise.  If a transmission is in progress, then queue
       the frame for later transmission, otherwise send the frame
       immediately.  Since the irhan() function can write a value
       of 0 to hwflags, interrupts are disabled between the time
       that the flag is written and the time that the this frame
       is set up. */
    DISABLE();
    if (netp->hwflags) {
        /* This next section is new, and is not implemented in
           current software.  The return code should be a
           special value to indicate that a frame had to be
           dropped, but for now the return value is 1,
           indicating that the frame was not queued. */
        if (QUEUE_FULL(netp, depart)) {
            ENABLE();
            netp->ifOutDiscards++;
            return 1;
        }
        QUEUE_IN(netp, depart, mess);
        ENABLE();
        return 0;
    }
    else {
        netp->hwflags = 1;
        /* The following code is the same that appears in the
           transmit section of the ISR. */
        len = mess->mlen - MESSH_SZ;
        /* Set up the frame for transmission.  The frame
           starts at (char *)mess + MESSH_SZ and is len
           bytes long.  Note that some ethernet controllers
           will automatically pad out frames that are
           shorter than the minimum ethernet frame size,
           others may not, and so len may need to be
           adjusted.  */
        /* Once the hardware has been programmed to send a
           frame, the offset field is set to the special
           value boTXDONE to indicate to other layers that
           the device driver no longer has control of the
           message buffer. */
        mess->offset = boTXDONE;
        ENABLE();
        return 1;
    }
}



More notes on writE() 

The check for QUEUE_FULL() is needed, and without this check, there is the
possibility that frames in the output queue will be lost. 

This example is for a system that sets up a frame for transmission inside the
writE() routine as well as inside the irhan() function. Another approach, if
the hardware supports it, is to just queue all frames and set up a transmit
buffer empty interrupt if needed to start emptying the depart queue. This can
save a little code space and simplify the driver. 




opeN() function 


static int opeN(int conno, int flag)
{
    (void) conno, (void) flag;
    return 0;
}



closE() function 


static int closE(int conno)
{
    (void) conno;
    return 0;
}



init() function 

Interprets device driver parameters, sets up hardware, and installs interrupt
vector. 
Returns 0 if device driver initialized successfully 
non-zero for error in initialization 


static int init(int netno, char *params)
{
    int i1;
    char par[16];
    char val[16];
    netp = &nets[netno];

    /* Pull the device driver parameters out of the string that
       is passed into this function.  This example shows the
       retrieval of values for IRNO and PORT.  Note that this
       section could be removed, and the values could be hard
       coded in order to avoid pulling the Nsscanf() function
       from the library.  This can save about 1300 bytes in a
       system that is low on ROM space. */
    for (cp1=params; *cp1; ) {
        Nsscanf(cp1, "%[^=]=%s %n", par, val, &i1);
        cp1 += i1;
        if (strcmp(par, "IRNO") == 0)
            Nsscanf(val, "%i", !=t]);
        else if (strcmp(par, "PORT") == 0)
            Nsscanf(val, "%i", &netp->port);
    }

    /* Call the adapter initialization.  This is currently used
       for PCMCIA support. */
    i1 = netp->protoc[2]->init(netno, params);
    if (i1 bps = 10000000;

    /* Reset the board, read the hardware address (if supported)
       and set up the controller for normal operation.  The
       hardware address should be stored in netp->id[0] through
       netp->id[5]. */

    /* Install interrupt vector to point to irhan(). */
    IRinstall(netp->irno[0], netno, irhan);

    /* Print out a debug message to indicate that device driver
       initialization was successful. */
#if NTRACE >= 1
    Nprintf("EXAMPLE %02x%02x%02x%02x%02x%02x IR%d\n",
            netp->id.c[0], netp->id.c[1], netp->id.c[2],
            netp->id.c[3], netp->id.c[4], netp->id.c[5],
            netp->irno[0]);
#endif

    /* All is OK, return 0 for success. */
    return 0;
}



shut() function 

Shuts down hardware. 

static void shut(int netno)
{
    struct NET *netp;

    netp = &nets[netno];
    /* Restore the original interrupt vector. */
    IRrestore(netp->irno[0]);
    /* Call the adapter layer shut down function. */
    netp->protoc[2]->shut(netno);
}



GLOBALCONST
PTABLE EXAMPLE_T = {"EXAMPLE", init, shut, 0, opeN, closE, 0,
    writE, 0, MESSH_SZ};



MIB Statistics 

USNET device drivers collect statistics to support SNMP. Currently the
following variables are maintained inside the device driver (definitions are
from RFC 1213): 

nets[].ifInDiscards 


"The number of inbound packets which were chosen
 to be discarded even though no errors had been
 detected to prevent their being deliverable to a
 higher-layer protocol.  One possible reason for
 discarding such a packet could be to free up
 buffer space."



nets[].ifInErrors 


"The number of inbound packets that contained
 errors preventing them from being deliverable to a
 higher-layer protocol."



nets[].ifOutDiscards 


"The number of outbound packets which were chosen
 to be discarded even though no errors had been
 detected to prevent their being transmitted.  One
 possible reason for discarding such a packet could
 be to free up buffer space."



nets[].ifOutErrors 


"The number of outbound packets that could not be
 transmitted because of errors."


The maintenance of these statistics could probably be conditionally compiled
using #ifdef MIB2 to further reduce code size. 

